<!DOCTYPEhtml>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Example 01.05 - dat.GUI UserInterface</title>
    <script type="text/javascript" src="../libs/three.js"></script>
    <script type="text/javascript" src="../libs/jquery-3.1.1.js"></script>
    <script type="text/javascript" src="../libs/stats.js"></script>
    <script type="text/javascript" src="../libs/dat.gui.js"></script>
    <style>
        body {
            /*set margin to 0 and overflow to hidden,to use thecomplete page*/
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>

    <div id="Stats-output"></div>
    <!--Div which will hold the Output-->
    <div id="WebGL-output"></div>

    <!--Javascript code that runs out Three.jsexamples-->
    <script type="text/javascript">
        //once everything is loaded, we run out Three.js stuff.
        function init() {
            var scene = newTHREE.Scene();

            var camera = newTHREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

            var renderer = newTHREE.WebGLRenderer();

            var stats = initStats();

            renderer.setClearColor(0xEEEEEE, 0.5);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMapType = THREE.PCFSoftShadowMap;
            renderer.shadowMapEnabled = true;

            var spotLight = newTHREE.SpotLight(0xffffff);
            spotLight.position.set(-40, 60, -10);

            spotLight.castShadow = true;
            spotLight.shadowMapHeight = 4096;
            spotLight.shadowMapWidth = 4096;
            scene.add(spotLight);

            var ambientLight = newã€€ THREE.AmbientLight(0xffffff);
            ambientLight.intensity = 0.3;
            scene.add(ambientLight);

            var axes = newTHREE.AxisHelper(20);
            scene.add(axes);

            var planeGeometry = new THREE.PlaneGeometry(60, 20, 1, 1);
            var planeMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff
            });
            var plane = newTHREE.Mesh(planeGeometry, planeMaterial);

            plane.rotation.x = -0.5 * Math.PI;
            plane.position.x = 15;
            plane.position.y = 0;
            plane.position.z = 0;

            plane.receiveShadow = true;

            scene.add(plane);

            var cubeGeometry = new THREE.CubeGeometry(4, 4, 4);
            var cubeMaterial = new THREE.MeshPhongMaterial({
                color: 0xff0000
            });
            var cube = newTHREE.Mesh(cubeGeometry, cubeMaterial);

            cube.position.x = -4;
            cube.position.y = 3;
            cube.position.z = 0;

            cube.castShadow = true;

            scene.add(cube);

            var sphereGeometry = newTHREE.SphereGeometry(4, 20, 20);
            var sphereMaterial = newTHREE.MeshPhongMaterial({
                color: 0x7777ff
            });
            var sphere = newTHREE.Mesh(sphereGeometry, sphereMaterial);

            sphere.position.x = 20;
            sphere.position.y = 4;
            sphere.position.z = 2;

            sphere.castShadow = true;

            scene.add(sphere);

            camera.position.x = -30;
            camera.position.y = 40;
            camera.position.z = 30;
            camera.lookAt(scene.position);
            document.getElementById("WebGL-output").appendChild(renderer.domElement);
            renderer.render(scene, camera);

            var controls = new function () {
                this.rotationSpeed = 0.02;
                this.bouncingSpeed = 0.03;
            };

            var gui = newdat.GUI();
            gui.add(controls, 'rotationSpeed', 0, 0.5);
            gui.add(controls, 'bouncingSpeed', 0, 0.5);

            //this renderScene() function should be called afterevery
            renderScene();

            var step = 0;

            function renderScene() {
                stats.update();

                //animate cube
                cube.rotation.x += controls.rotationSpeed;
                cube.rotation.y += controls.rotationSpeed;
                cube.rotation.z += controls.rotationSpeed;

                //animate sphere
                step += controls.bouncingSpeed;
                sphere.position.x = 20 + (10 * Math.cos(step));
                sphere.position.y = 2 + (10 * Math.abs(Math.sin(step)));

                requestAnimationFrame(renderScene);
                renderer.render(scene, camera);
            }

            function initStats() {
                var stats = newStats();
                stats.setMode(0);
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.left = '0px';
                stats.domElement.style.top = '0px';
                document.getElementById("Stats-output").appendChild(stats.domElement);

                return stats;
            }
        }
        window.onload = init;
    </script>

</body>

</html>